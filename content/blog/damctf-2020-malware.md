---
title: "DamCTF 2020 - IcyRetina (Malware Challenge)"
date: 2020-10-11T17:00:00-07:00
draft: true
toc: true
tags:
  - damctf
  - ctf
  - security
---

[DamCTF](https://ctftime.org/event/1076) is a cybersecurity Capture the Flag competition, hosted by the [OSU Security Club](https://www.osusec.org/). This past weekend was our first public offering of the event, and I am very pleased with how it went. This blog post describes a sequence of challenges I built where the player takes the role of a malware researcher at a fictitious company called IcyRetina, analzying a new threat and working to compromise the actor's systems. I will go over some of the factors that went into the design of the challenge, and my solutions to each phase.

_Parts of this scenario are lightly based on some work I did at a past cybersecurity company on an intership, whose name bears no resemblance to this challenge_

## Scenario

The challenge had 5 phases, each building on the last and uncovering more information about the malware and it's operators:

1. Finding the malware sample in a PCAP file
2. Extracting the malware's config from a single sample
3. Automating the config extraction process
4. Compromising the Command & Control (C2) server
5. Compromising the operator's administrative web panel

Players found themselves working for a fictitious cybersecurity company called IcyRetina, and would receive new information from other analysts on their team as they worked through each of the challenges.

The source code for the entire challenge is available [here](https://gitlab.com/osusec/damctf-2020/-/tree/master/malware)

## Phase 1

> As a part of your daily work at IcyRetina (one of the world's most premier cybersecurity companies), you're always finding interesting malware and exploits in client environments. Today, you're triaging an alert for some traffic at a client site that triggered one of your Snort rules (called `CLEARTEXT_ELF_LIB`). Can you find something suspicious in the PCAP?
> 
> _The flag for this challenge is the lowercase SHA-256 hash of the suspicious file, wrapped in `dam{...}`_
> 
> [Download PCAP](https://gitlab.com/osusec/damctf-2020/-/raw/master/malware/phase1/alert.pcapng)

Players are given a PCAP file with a couple thousand packets, and need to find the malware sample to continue their analysis in Phase 2. Luckily, the challenge description indicates that the file in question is an ELF, and there is only one occurence of `ELF` in packet data. Players could use Wireshark to manually export the file contents, but I used [Zeek](https://zeek.org/) to extract the file:

```
$ zeek -C -r alert.pcapng policy/frameworks/files/extract-all-files.zeek
```

There are only 4 files extracted by Zeek, so players can easily identify which one is the malware:

```
$ file extract_files/*
extract_files/extract-1601075727.716824-SSL-FF3y541p5rePWfuhN6:  data
extract_files/extract-1601075727.716824-SSL-Fg9sbh18GWhtmeepjc:  Certificate, Version=3
extract_files/extract-1601075727.716824-SSL-FpqOmi45F9BlaeneKd:  Certificate, Version=3
extract_files/extract-1601075730.597745-HTTP-FvtuaL37IjCnEVi3Oa: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=31cb8cc7d49dbc9d6894c9f082116d2c739b8753, stripped
$ sha256sum extract_files/extract-1601075730.597745-HTTP-FvtuaL37IjCnEVi3Oa 
fc5333c5d1de963b52e57c512e10cf0e37153ac917b7040cf5f95a628a601b10  extract_files/extract-1601075730.597745-HTTP-FvtuaL37IjCnEVi3Oa
```

Flag for Phase 1:
```
dam{fc5333c5d1de963b52e57c512e10cf0e37153ac917b7040cf5f95a628a601b10}
```

## Phase 2

> Nice work finding that suspicious file! Using IcyRetina's extensive collection of Yara rules, you were able to identify that the sample is definitely malicious, but very little is known about it. Can you extract the config from the malware?
> 
> _There is a chunk of encrypted data that is accessed early on in the malware's execution. That is the the malware's config._

Phase 2 required players to successfully extract the ELF from the PCAP in Phase 1. If you are following along and would like to skip the file extraction, you can download the ELF [here](https://gitlab.com/osusec/damctf-2020/-/raw/master/malware/phase2/libmal.so).

To make it easier to start reversing, there are only two functions exported from the library: `libinit` and `libmain`.

_Please note: In order to make it easier for readers to follow along with the analysis, I won't be renaming any of the symbols in the analysis. However, I strongly suggest that as you work through a binary and figure out what something does (or even just a hunch or something interesting) that you rename the function to reflect it. It will make your life much easier, trust me._

```c
void libinit(void)

{
  time_t tVar1;
  
  tVar1 = time((time_t *)0x0);
  srand((uint)tVar1);
  FUN_00101bbf();
  FUN_0010307c(&DAT_00106c60);
  DAT_00106c40 = 1;
  return;
}
```

`libinit()` is a simple function that configures the random seed, calls a couple functions, and sets a global variable. Let's take a look at `FUN_00101bbf()`:

```c
void FUN_00101bbf(void)

{
  int local_c;
  
  local_c = 0;
  while (local_c < 10) {
    if (((&DAT_001061a0)[(long)local_c * 0x32] & 4) != 0) {
      FUN_00101a19(PTR_DAT_00106398,&DAT_001061a0 + (long)local_c * 0x32,
                   &DAT_001061a0 + (long)local_c * 0x32);
      (&DAT_001061a0)[(long)local_c * 0x32] = 8;
    }
    local_c = local_c + 1;
  }
  return;
}
```

This function loops through an array of data at `DAT_001061a0` in 0x32 byte chunks, and if `chunk[0] & 0x4 != 0`, it calls `FUN_00101a19()`, passing a pointer to some data, and then two copies of the array chunk.

If we take a look at `FUN_00101a19()`, we realize that there are only two arguments to the function (which makes sense, because args 2 and 3 were identical):

```c
void FUN_00101a19(uchar *param_1,long param_2)

{
  uchar uVar1;
  int iVar2;
  uchar *indata;
  uchar *indata_00;
  long in_FS_OFFSET;
  int local_434;
  RC4_KEY local_418;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  indata = (uchar *)calloc(0x31,1);
  indata_00 = (uchar *)(param_2 + 1);
  RC4_set_key(&local_418,0x20,param_1);
  RC4(&local_418,0x31,indata,indata);
  local_434 = 0x30;
  while (-1 < local_434) {
    iVar2 = (int)(local_434 + (uint)indata[local_434]) % 0x31;
    uVar1 = indata_00[local_434];
    indata_00[local_434] = indata_00[iVar2];
    indata_00[iVar2] = uVar1;
    local_434 = local_434 + -1;
  }
  RC4(&local_418,0x31,indata_00,indata_00);
  free(indata);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

This function uses the RC4 capabilities in OpenSSL to do some sort of crypto on the data passed by `param_2`, and uses `param_1` as the key. The data is shuffled like a stream cipher, and then run through RC4 to be decrypted. Here is my Python re-implementation of the decryption function:

```py
def fun_00101a19(key, chunk):
    cipher = ARC4.new(key)
    indata_00 = list(chunk[1:])

    indata = b"\x00" * 0x31

    indata = list(cipher.decrypt(indata))

    for i in range(48, -1, -1):
        iVar2 = (indata[i] + i) % 49
        uVar1 = indata_00[i]
        indata_00[i] = indata_00[iVar2]
        indata_00[iVar2] = uVar1

    return cipher.decrypt(bytes(indata_00))
```

Now that we know how to decrypt the config, we need to know where the key and the encrypted config is in the binary. Looking back at `FUN_00101bbf()`, we know that `PTR_DAT_00106398` is a pointer to some data:

{{< figure src="/img/damctf/phase2_ptr.png" >}}

If we look at `DAT_00104010`, we see a 32 byte, null terminated string. This looks like our key value!

{{< figure src="/img/damctf/phase2_key.png" >}}

Now we need to locate where the encrypted data is. `FUN_00101bbf` uses `DAT_001061a0` for the second argument as the base of the array, so let's check there to make sure it's the config block:

{{< figure src="/img/damctf/phase2_config.png" >}}

It looks to be a lot of encrypted data, and starts with a `0x4` byte, which aligns with the check done at the beginning of `FUN_00101bbf`.

In order to properly automate the config extraction, we need to know where the bytes actually are in the binary file, rather than the segment address in memory or something else. Luckily, this is easy to determine with Ghidra (at least for this binary). The data segment addresses shown in Ghidra can be subtracted from `0x101000` to get the actual value in the binary. For example, data at `0x1061a0` in Ghidra is physically located at offset `0x51a0` in the binary file.

With all of this knowledge on the config and how it is encrypted, a script can be written to extract each chunk and decrypt it. Here is my final solution script for this phase:

<!-- {{< gist captainGeech42 c40415477c7626390777cedefbac67a9 >}} -->

```py
from Crypto.Cipher import ARC4
import sys

# read in malware
with open(sys.argv[1], "rb") as f:
    data = f.read()

# get data
config_block = data[0x51a0:0x5394]
key_len = 32
config_key = data[0x4010:0x4010+key_len]

chunk_len = 50

# chunk[0] & 0x4, encrypted
# chunk[0] & 0x8, decrypted

def fun_00101a19(key, chunk):
    cipher = ARC4.new(key)
    indata_00 = list(chunk[1:])

    indata = b"\x00" * 0x31

    indata = list(cipher.decrypt(indata))

    for i in range(48, -1, -1):
        iVar2 = (indata[i] + i) % 49
        uVar1 = indata_00[i]
        indata_00[i] = indata_00[iVar2]
        indata_00[iVar2] = uVar1

    return cipher.decrypt(bytes(indata_00))

for i in range(len(config_block)//chunk_len):
    plaintext = fun_00101a19(config_key, config_block[i*chunk_len:(i+1)*chunk_len])
    key = plaintext[:4].decode()
    val = plaintext[4:].decode().split("\x00")[0]
    print(f"{key} = {val}")
```

When we run that script, we are able to view the config for the binary, along with the flag:

```
$ python3 phase2.py libmal.so
stky = 7a9d6fad3798a7867a9d6fad3798a786
cont = bhuwehobiwsnbqpxnws.damctf.xyz
jgie = google.com
slti = 300
xvee = facebook.com
flag = dam{1m4g1n3_m4k1ng_w1nd0ws_m4lw4re_lma0}
ehbn = amazon.com
bnwe = microsoft.com
stiv = f83646fad02d42e6
port = 3613
```

## Phase 3

> Great work extracting the config from that malware! Based on your analysis, we've identified many other samples for another variant that appears to be using a slightly different config encryption function. Can you automate the config extraction for these new samples?
> 
> Please connect to our sample server to receive samples for analysis: `nc chals.damctf.xyz 32153`

Now that players knew where the malware config was located and generally how to extract the flag, they would need to automate that extraction process to provide a specified config item from 10 different binaries within 60 seconds. The "sample server" had 3000 different binaries that had [randomly generated configs](https://gitlab.com/osusec/damctf-2020/-/blob/master/malware/phase3/generate_binaries/gen.py#L28). However, we threw a curveball at players by modifying the config encryption code for the phase 3 binaries, so players would have to save the first binary for manual analysis to build their solving script.

When players connect to the service, they are given a Base64 blob of the ELF to analyze, and then are prompted to provide a config value:

```
What's the value of the 'xvee' config item?
```

Assuming they provide the correct config value, they will repeat the process 10 times and will then be given the flag.

Let's take a look at the new config decryption code from one of the binaries:

```c
void FUN_00101a19(uchar *param_1,long param_2)

{
  char *__src;
  uchar *outdata;
  long in_FS_OFFSET;
  byte local_455;
  int local_454;
  int local_450;
  RC4_KEY local_438;
  byte local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __src = (char *)(param_2 + 1);
  RC4_set_key(&local_438,0x20,param_1);
  outdata = (uchar *)calloc(0x42,1);
  RC4(&local_438,0x10,param_1,outdata);
  strncpy((char *)(outdata + 0x10),__src,0x31);
  local_454 = 0;
  while (local_454 < 0x31) {
    RC4(&local_438,0x10,outdata + local_454,local_28);
    local_455 = 0;
    local_450 = 0;
    while (local_450 < 0x10) {
      local_455 = local_455 ^ local_28[local_450];
      local_450 = local_450 + 1;
    }
    __src[local_454] = __src[local_454] ^ local_455;
    local_454 = local_454 + 1;
  }
  free(outdata);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

`FUN_00101a19` in Phase 3 uses RC4-CFB8, which for some reason is a supported crypto scheme in OpenSSL but I've been told should never be used and is effectively a meme (dear crypto people: I am not a crypto person, and apologize in advance). One of OSUSEC's resident crypto experts helped with the specific crypto implementations for phases 2 and 3, otherwise it would've just been random XOR if I had implemented it (thanks Athos!).

{{< figure src="/img/damctf/xor.png" caption="Guide to solving beta version of Phase 2/3" class="center" >}}

Using the above decompilation, we can write a new function in Python to decrypt a config chunk, along with the other code necessary to interact with the service:

```py
from pwn import *
import sys
from Crypto.Cipher import ARC4
import base64
from typing import Dict

def get_config(elf: bytes) -> Dict[str, str]:
    def decrypt_chunk(key, chunk):
        cipher = ARC4.new(key)
        outbytes = list(chunk[1:])

        ret = cipher.decrypt(key[:16])
        ptr = ret + chunk[1:] 

        for i in range(49):
            ret = cipher.decrypt(ptr[i:i+16])
            local_455 = 0
            for j in range(16):
                local_455 ^= ret[j]
            outbytes[i] ^= local_455

        return bytes(outbytes)

    config_bytes = elf[0x51a0:0x5394]
    config_key = elf[0x4010:0x4010+32]

    config = {}

    for i in range(10):
        plaintext = decrypt_chunk(config_key, config_bytes[i*50:(i+1)*50])
        key = plaintext[:4].decode()
        val = plaintext[4:].decode().split("\x00")[0]
        config[key] = val
    
    return config

p = remote(sys.argv[1], int(sys.argv[2]))

p.sendlineafter("continue)", "")

for _ in range(10):
    p.recvline()
    a = p.recvline()
    elf = base64.b64decode(p.recvline())

    config = get_config(elf)
    line = p.recvline()
    key = line.decode().split("'")[2][:4]
    p.sendline(config[key])

    p.recvline()

p.recvline()
print(p.recvline().decode())
```

Running that script will grant us the Phase 3 flag after ~15 seconds:

```
$ python3 interact.py chals.damctf.xyz 32153
[+] Opening connection to chals.damctf.xyz on port 32153: Done
dam{w0w_c0nf1gs_ar3_sup3r_import4nt_f0r_analys1s}
```

## Phase 4

> Our sensors just detected another sample for the malware on an endpoint in a client's environment. There was also some suspicious network traffic flagged on the host, so we are hoping to find a live Command & Control (C2) server this time!
> 
> Thanks to the information you've uncovered throughout your analysis, our research team has learned a lot about the threat actors behind this malware, and has determined that they don't always adhere to secure coding practices. Can you find a vulnerability in the C2 communication/command protocol that would let you "borrow" files from the server? (don't worry, Legal signed off on it!)
> 
> _The flag is on the C2 server at `/flag`_
> 
> [Download new sample](https://gitlab.com/osusec/damctf-2020/-/raw/master/malware/phase4/libmal.so)

Phase 4 is where the difficulty gets kicked up a notch, and players need to analyze the custom binary protocol that is used between the malware and the C2 server. Only ~20% of the teams who solved Phase 3 solved Phase 4. The task was originally designed to be solved with just the ELF (which is identical to the Phase 1/2 ELF, just with a different config that had a live C2 server), but after seeing no solves for 18 hours, I was worried that the difficulty jump was too high between 3 and 4, and that teams wouldn't be able to solve it within a reasonable time period. After some discussion with the other admins, we decided to release a [PCAP](https://gitlab.com/osusec/damctf-2020/-/raw/master/malware/phase4/c2comms.pcapng) that showed the communication between the malware and the C2 server. This was a decision I did not take lightly, as I didn't want to negatively affect the competitiveness of the event, but I also wanted people to be able to solve Phase 4 (and unlock Phase 5) and have the joy of solving the full sequence.

After talking with a couple teams and asking about the PCAP release on the survey, all teams appreciated having the PCAP except for one team who had already done a lot of reversing work and didn't really need the PCAP to help solve the challenge. Allow me to make something clear: **If ANY team had solved Phase 4, we would not have released a PCAP.** However, since there were no solves, we felt it didn't adversely affect the competitive nature of the CTF to release one. I also monitored the backend database and logs for the C2 server to check player's progress before releasing the PCAP, and it didn't seem like anyone had managed to move past the initial bot registration message. With all of that in mind, we deemed it fair and just to release the PCAP. If anyone has additional thoughts about this type of in-event challenge modification, please [contact me](https://twitter.com/captainGeech42), I would love to hear your thoughts (we are very new CTF organizers and are still figuring out the best way to do things).

Anyways, let's talk about how to solve this challenge. I'll briefly touch on the strategy for solving this without the PCAP (tl;dr lots of reversing), and then will go through solving it with the PCAP, as that's what most teams did during the CTF.

### No PCAP

The description indicates that we are looking for a way to access files on the C2 server, potentially through some form of RCE or otherwise. In order to start investigating how to achieve this, we can start by fully tearing apart the malware, starting with the string encryption.

In (most) places where a string would normally be found, a function call is made with a single parameter, indicating which string should be returned:

```c
lVar2 = FUN_00102e48(0x13);
```

I say "most" strings, because if we look at the strings found in the ELF, we see that there are a few relevant ones present:

```
$ strings libmal.so
[snip]
GLIBC_2.2.5
u3UH
dH+4%(
AUATSH
H[A\A]]
ATSH
0[A\]
cont
port
slti
stiv
stky
;*3$"
l~oK$5
)R9u
lE2j
v_Zl
snip
```

The strings `cont`, `port`, `slti`, `stiv`, and `stky` seem familiar. Why? Because they are key names in the malware config! As we analyze the string crypto at `FUN_00102e48`, we will see that `stiv` and `stky` are the IV and key used for string encryption, and therefore the strings used to access the config can't themselves be encrypted, otherwise there would be an infinite loop of no-string-ness.

Let's take a look at `FUN_00102e48` and try to decrypt the other strings in the binary, as this will make our analysis a bit easier:

```c
long FUN_00102e48(uint param_1)

{
  if ((&DAT_001063a0)[(long)(int)param_1 * 0x61] != '\b') {
    FUN_00102ece((ulong)param_1);
  }
  return (long)(int)param_1 * 0x61 + 0x1063a1;
}

void FUN_00102ece(int param_1)

{
  int iVar1;
  uchar *iv;
  uchar *key;
  EVP_CIPHER *cipher;
  long in_FS_OFFSET;
  int local_34;
  EVP_CIPHER_CTX *local_30;
  uchar *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = EVP_CIPHER_CTX_new();
  if (local_30 == (EVP_CIPHER_CTX *)0x0) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  iv = (uchar *)FUN_00101933(&DAT_00104036);
  key = (uchar *)FUN_00101933(&DAT_0010403b);
  cipher = EVP_aes_256_cbc();
  iVar1 = EVP_DecryptInit_ex(local_30,cipher,(ENGINE *)0x0,key,iv);
  if (iVar1 != 1) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  EVP_CIPHER_CTX_set_padding(local_30,0);
  local_28 = (uchar *)malloc(0x61);
  iVar1 = EVP_DecryptUpdate(local_30,local_28,&local_34,(uchar *)((long)param_1 * 0x61 + 0x1063a1),
                            0x60);
  if (iVar1 != 1) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  iVar1 = EVP_DecryptFinal_ex(local_30,local_28 + local_34,&local_34);
  if (iVar1 != 1) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  EVP_CIPHER_CTX_free(local_30);
  memcpy((void *)((long)param_1 * 0x61 + 0x1063a1),local_28,0x60);
  free(local_28);
  (&DAT_001063a0)[(long)param_1 * 0x61] = 8;
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

Like the config crypto, the main accessor function will check to see if the first byte is equal to `0x8`, and if not, will call `FUN_00102ece` to (presumably) decrypt the string, and then return the pointer to the string.

Ghidra very helpfully parses all of the relevant OpenSSL variables for us, so we can quickly identify the key and IV variables, and how they are used in the code. Fortunately for us as the reverse engineer, this function just does a standard AES-256-CBC decryption on the string chunk specified by the int in `param_1`. We also see that each chunk is 97 bytes, and that the first byte is a status byte that isn't returned to the caller, so each string is 96 bytes, including a terminating null byte.

For some reason, Ghidra doesn't properly identify the strings passed to `FUN_00101933` to fill the `iv` and `key` variables, but `DAT_00104036` is `stiv\x00`, and `DAT_0010403b` is `stky\x00` (you can view the values by double clicking on those symbolsin Ghidra). From this, we can infer that the `stiv` entry in the config is the IV value for the cipher, and `stky` the key value.

Here is a Python function that can decrypt all of the strings in the binary (the full string decryption script is available [here](https://gitlab.com/osusec/damctf-2020/-/blob/master/malware/phase4/sol/dec_str.py)):

```py
def get_strs(elf: bytes, iv: str, key: str):
    strs_chunk = elf[0x53a0:0x53a0+2134]
    strlen = 97 # status + 96chars

    def fun_00102ece(num):
        cipher = AES.new(key=key.encode(), iv=iv.encode(), mode=AES.MODE_CBC)
        plaintext = cipher.decrypt(strs_chunk[(num*strlen)+1:(num+1)*strlen])

        return plaintext

    strs = []
    for i in range(len(strs_chunk) // strlen):
        strs.append(fun_00102ece(i).decode().split("\x00")[0])

    return strs
```

Let's run the script and see what the strings are:

```
$ python3 dec_str.py
0x0     IV
0x1     noop
0x2     ack
0x3     netw
0x4     user
0x5     runs
0x6     runc
0x7     down
0x8     upld
0x9     exit
0xa     r
0xb     /etc/passwd
0xc     /etc/shadow
0xd     /etc/sudoers
0xe     %s%s%s
0xf     fail
0x10    good
0x11    w
0x12    skip
0x13    0123456789abcdef
0x14    aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa
0x15    /tmp/
```

Now, whenever we see something in the decompilation that calls `FUN_00102e48`, we will be able to easily identify what the decrypted string is.

Let's start taking a look at the actual meat of the binary, starting with `libmain()`:

```c
void libmain(void)

{
  uint __seconds;
  uint __fd;
  char *__nptr;
  long in_FS_OFFSET;
  undefined local_88 [4];
  undefined2 local_84;
  void *local_80;
  undefined local_78;
  char acStack119 [37];
  undefined2 local_52;
  undefined8 local_50;
  char local_48 [38];
  undefined2 local_22;
  undefined8 local_20;
  undefined8 local_10;
  
  local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28);
  if (DAT_00106c40 != '\x01') {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  __nptr = (char *)FUN_00101933(&DAT_00104031);
  __seconds = atoi(__nptr);
  FUN_00101ce7();
  sleep(__seconds);
  do {
    local_50 = 0;
    local_52 = 0;
    local_20 = 0;
    local_22 = 0;
    local_80 = (void *)0x0;
    local_84 = 0;
    __fd = FUN_00101399();
    local_78 = 3;
    strncpy(acStack119,&DAT_00106c60,0x24);
    FUN_001014be((ulong)__fd,&local_78,1,&local_78);
    local_84 = 0;
    local_80 = (void *)0x0;
    FUN_00101775((ulong)__fd,local_88,local_48,local_88);
    if (local_48[0] == '\x04') {
      FUN_00101d96((ulong)__fd,local_88,local_88);
      if (local_80 != (void *)0x0) {
        free(local_80);
      }
    }
    close(__fd);
    sleep(__seconds);
  } while( true );
}
```

We see that a function `FUN_00101ce7()` is called, then `sleep()`, and then an infinite loop that probably polls the C2 server for a new command. Using our handy dandy config extractor, we know that the value used as the argument to `sleep()` comes from the config key `slti`, which is `300`:

```
$ python3 config_extract.py phase4/libmal.so 
ehbn = uiw.edu
slti = 300
stky = 2817e98390fe52c9dbcc0ac31b789d8c
jgie = namemc.com
port = 31996
stiv = 0c4aaaf59534932e
nklr = moneyou.de
cont = gardenpartydelite.be
bnwe = ecitizen.go.ke
xvee = numimarket.pl
```

At this point, I am going to switch to PCAP-informed reversing of the binary. All of this analysis is possible without the PCAP, but it's a bit more difficult. I highly encourage you to try and reverse engineer the sample without the PCAP for practice.

### With a PCAP

Let's start by taking a look at the PCAP in Wireshark:

{{< figure src="/img/damctf/phase4_pcap1.png" >}}

We see 4 connections, one at T+0 seconds, two at ~T+300 seconds, and a fourth at T+602 seconds

The first connection sends the following data:

```
00000000  01 64 37 32 61 62 39 35 66 2d 32 32 32 36 2d 34  |.d72ab95f-2226-4|
00000010  61 34 30 2d 61 34 63 61 2d 65 31 35 33 39 32 66  |a40-a4ca-e15392f|
00000020  36 39 31 30 34 00 00                             |69104..|
```

It sends it in two packets, with the first packet only having the `0x01` byte at the beginning, and the second with all of the rest of the data. Bytes 0x01-0x25 look like a UUIDv4, which is most likely the bot ID (you can see this generated with `FUN_0010307c()` in the binary).

Let's take a look at the response:

```
00000000  02 64 37 32 61 62 39 35 66 2d 32 32 32 36 2d 34  |.d72ab95f-2226-4|
00000010  61 34 30 2d 61 34 63 61 2d 65 31 35 33 39 32 66  |a40-a4ca-e15392f|
00000020  36 39 31 30 34 20 00 4b e7 f0 5d eb 91 94 61 bc  |69104 .K..]...a.|
00000030  5c 90 94 1a a2 fb df ec 58 41 ef 3c d6 d7 4e 5c  |\.......XA.<..N\|
00000040  c3 07 63 87 66 d8 69                             |..c.f.i|
```

To understand what all of these bytes are, let's refer back to `libmain()`, and start looking for functions that do network communication. `libmain` calls `FUN_00101ce7` before entering a loop:

```c
void FUN_00101ce7(void)

{
  uint __fd;
  long in_FS_OFFSET;
  undefined local_48;
  char acStack71 [37];
  undefined2 local_22;
  void *local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_48 = 1;
  strncpy(acStack71,&DAT_00106c60,0x24);
  local_22 = 0;
  __fd = FUN_00101399();
  FUN_001014be((ulong)__fd,&local_48,0,&local_48);
  FUN_0010157c((ulong)__fd,&local_48,0,&local_48);
  FUN_0010190c(local_20);
  free(local_20);
  close(__fd);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

We know that `DAT_00106c60` contains the output from the UUIDv4 generated by `libinit()`. It looks like a struct is built on the stack, and then passed to `FUN_00104be` and `FUN_0010157c`. Ghidra also thinks the return value from `FUN_00101399()` is some sort of file descriptor, so that probably opens the socket to the C2 server.

```c
ulong FUN_00101399(void)

{
  // truncated/simplified for readability
  __nptr = (char *)FUN_00101933(&DAT_00104005); // port
  iVar2 = atoi(__nptr);
  __nptr = (char *)FUN_00101933(&DAT_00104000); // cont
  phVar3 = gethostbyname(__nptr);

  __fd = socket(2,1,0);
  local_20 = 0;
  local_28 = 2;
  uVar1 = htons((uint16_t)iVar2);
  memcpy((void *)((long)&local_28 + 4),*phVar3->h_addr_list,(long)phVar3->h_length);

  iVar2 = connect(__fd,(sockaddr *)&local_28,0x10);
  return (ulong)__fd;
}

void FUN_001014be(int param_1,void *param_2,char param_3)

{
  write(param_1,param_2,1);
  write(param_1,(void *)((long)param_2 + 1),0x24);
  write(param_1,(void *)((long)param_2 + 0x26),2);
  if ((param_3 != '\0') && (*(short *)((long)param_2 + 0x26) != 0)) {
    FUN_00101882(*(undefined8 *)((long)param_2 + 0x28),(ulong)*(ushort *)((long)param_2 + 0x26),
                 (ulong)*(ushort *)((long)param_2 + 0x26));
  }
  if (*(short *)((long)param_2 + 0x26) != 0) {
    write(param_1,*(void **)((long)param_2 + 0x28),(ulong)*(ushort *)((long)param_2 + 0x26));
  }
  return;
}

void FUN_0010157c(int param_1,void *param_2,char param_3)

{
  void *pvVar1;
  
  if (param_2 != (void *)0x0) {
    read(param_1,param_2,1);
    read(param_1,(void *)((long)param_2 + 1),0x24);
    read(param_1,(void *)((long)param_2 + 0x26),2);
    if (*(short *)((long)param_2 + 0x26) == 0) {
      *(undefined8 *)((long)param_2 + 0x28) = 0;
    }
    else {
      pvVar1 = malloc((ulong)*(ushort *)((long)param_2 + 0x26));
      *(void **)((long)param_2 + 0x28) = pvVar1;
      read(param_1,*(void **)((long)param_2 + 0x28),(ulong)*(ushort *)((long)param_2 + 0x26));
    }
    if ((param_3 != '\0') && (*(short *)((long)param_2 + 0x26) != 0)) {
      FUN_001018e6(*(undefined8 *)((long)param_2 + 0x28),(ulong)*(ushort *)((long)param_2 + 0x26),
                   (ulong)*(ushort *)((long)param_2 + 0x26));
    }
  }
  return;
}
```

It looks like a connection is opened to the server, and the struct at `param_2` is written to the socket in `FUN_001014be()`, and then data is read off the socket into the struct at `param_2` in `FUN_0010157c()`.

Now that we see how the data is being used, we can assemble a rough idea of what the struct looks like:

```c
typedef struct {
    unsigned char unknown;
    char id[0x24];
    unsigned short length;
    void *data;
} packet_t;
```

How do we know what the different fields are from the above decompilation?

* In the PCAP, we see the ID value being sent at offset `0x01`, so we can assume that the `0x24` byte chunk being read off the wire is the ID.
* In `FUN_001014be()`, the `short` at `param_2+0x26` must be `!= 0` for the data pointed to by `param_2+0x28` to be written to the socket, and the length argument on the `write()` call is `param_2+0x26` (along with the argument to `malloc()`), so it is safe to assume that offset `0x26` is a `unsigned short` length value for the packet data.

Something curious is happening in both `FUN_001014be()` and `FUN_0010157c`, if the `packet_t.length != 0` and `param_3 != 0`. If those conditions are met, the function `FUN_00101882()` or `FUN_001018e6()` is called, with the argument of the `packet_t.data` pointer. Let's take a look at that code and see what it does:

```c
void FUN_00101882(long param_1,ushort param_2)

{
  uint uVar1;
  int local_c;
  
  local_c = 0;
  while (local_c < (int)(uint)param_2) {
    uVar1 = (uint)(local_c >> 0x1f) >> 0x1b;
    *(byte *)(param_1 + local_c) =
         (&DAT_00106c20)[(int)((local_c + uVar1 & 0x1f) - uVar1)] ^ *(byte *)(param_1 + local_c);
    local_c = local_c + 1;
  }
  return;
}

void FUN_001018e6(undefined8 param_1,ushort param_2)

{
  FUN_00101882(param_1,(ulong)param_2,(ulong)param_2);
  return;
}
```

We see that there is an XOR encryption being performed on the data passed in, and that `param_1` is the data pointer, and `param_2` is the length of the data. We also know that the key is located at `DAT_00106c20`, and that `FUN_001018e6()` just calls `FUN_00101882()` without changing the arguments. We can make the following conclusions from this:

* Because basic XOR encryption and decryption is the same, we can assume taht `FUN_001018e6()` is a "decrypt" function that just calls the "encrypt" function (`FUN_00101882()`) since it can serve the same purpose
* The `param_3` argument to `FUN_001014be()` and `FUN_0010157c()` is most likely a boolean value to indicate whether or not the XOR code should be called to encrypt/decrypt some data (assuming `packet_t.length != 0`)

Unfortunately, the data at `DAT_00106c20` is all NULL, which implies that the key is dynamically generated. Luckily, we are able to identify that the key is the extra data sent back from the server by taking another look at a function call in `FUN_00101ce7()`, after the send and receive code is finished executing. The function then calls `FUN_0010190c()`, passing in the `packet_t.data` struct value.

```c
void FUN_0010190c(char *param_1)

{
  strncpy(&DAT_00106c20,param_1,0x20);
  return;
}
```

It looks like `FUN_0010190c()` copies 32 bytes from the pointer to `DTA_00106c20`, which confirms that the data in the initial response from the server is an encryption key for future communications.

Now that we know how and what parts of the communication are encrypted, along with the key, we can look at the rest of the packets and decrypt them:

```
Packets 17,19 Client->Server
00000000  03 64 37 32 61 62 39 35 66 2d 32 32 32 36 2d 34  |.d72ab95f-2226-4|
00000010  61 34 30 2d 61 34 63 61 2d 65 31 35 33 39 32 66  |a40-a4ca-e15392f|
00000020  36 39 31 30 34 00 00                             |69104..|
```

This packet has zero data bytes, and therefore needs no decryption

```
Packet 21 Server->Client
00000000  04 64 37 32 61 62 39 35 66 2d 32 32 32 36 2d 34  |.d72ab95f-2226-4|
00000010  61 34 30 2d 61 34 63 61 2d 65 31 35 33 39 32 66  |a40-a4ca-e15392f|
00000020  36 39 31 30 34 19 00 2f 88 87 33 f8 91 bb 14 cf  |69104../..3.....|
00000030  2e bf f8 73 c0 d4 b0 9f 75 33 8a 50 b3 b6 3d 39  |...s....u3.P..=9|
```

This packet has `0x19` data bytes, and can be decrypted! We can use [this script](https://gitlab.com/osusec/damctf-2020/-/blob/master/malware/phase4/sol/dec_pkt.py) to decrypt the packet:

```py
import binascii
import struct
import sys

def decrypt_packet(key, packet):
    packet = binascii.unhexlify(packet)

    length = struct.unpack("<H", packet[37:39])
    if length == 0:
        return

    enc_bytes = packet[39:]

    key = binascii.unhexlify(key)

    out_pkt = b""
    for i in range(len(enc_bytes)):
        out_pkt += bytes([enc_bytes[i] ^ key[i % len(key)]])

    return out_pkt

def main(argv):
    if len(argv) != 3:
        print("usage: ./dec_pkt.py [key binascii] [pkt binascii]")
        return 1

    print(decrypt_packet(argv[1], argv[2]))
    
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
```

```
$ ./dec_pkt.py 4be7f05deb919461bc5c90941aa2fbdfec5841ef3cd6d74e5cc307638766d869 0464373261623935662d323232362d346134302d613463612d65313533393266363931303419002f888733f891bb14cf2ebff873c0d4b09f75338a50b3b63d39
b'down\x13\x00/usr/lib/os-release'
```

## Phase 5

> Congratulations on exploiting the C2 server, you should be proud of yourself! You enabled the rest of your team to uncover a wealth of new intelligence on the malware, including what looks to be the operator panel for it! If you are able to compromise their panel, we'll be able to learn even more about these actors.
> 
> Take a look at the panel and see what you can find (somehow, Legal signed off on this again)!
> 
> [expressrentals.uk](https://expressrentals.uk)
> 
> _The flag is on the webpanel server at `/flag`_

asdf